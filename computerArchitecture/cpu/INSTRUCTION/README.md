# CPU
## INSTRUCTION
### 명령어 사이클
1. 인출(instruction fetch) -> 인출 사이클
2. 실행(instruction execution) -> 실행 사이클

### 인출 사이클
1. 프로그램 카운터(PC)가 가리키는 주소의 명령어 인출
2. MAR을 통해 주소 전송
3. 기억 장치 명령어 읽음
4. MBR에 데이터 적재, PC 주소 증가 -> 다음 명령어 주소 가리킴
5. MBR 명령어 코드 IR로 이동

### 실행 사이클
#### 데이터 이동
```
## LOAD addr

t0: MAR <- IR(addr)
t1: MBR <- M[MAR]
t2: AC <- MBR

## 기억장치 데이터 -> AC 이동
## 오퍼랜드(addr): 연산 코드의 주소
```
0. IR에 적재된 오퍼랜드를 MAR를 통해 기억장치로 전송
1. 메모리의 데이터 인출하여 MBR에 저장
2. 데이터 AC 레지스터에 적재

#### 데이터 저장
```
## STA addr

t0: MAR <- IR(addr)
t1: MBR <- AC
t2: M[MAR] <- MBR

```
0. 데이터 저장할 메모리 주소 MAR 전송
1. 저장할 데이터 MBR 이동
2. 메모리 데이터 저장

#### 데이터 처리
```
## ADD addr

t0: MAR <- IR(addr)
t1: MBR <- M[MAR]
t2: AC <- AC + MBR
```
0. 오퍼랜드 기억장치로 전송
1. 기억장소 데이터 인출 후 적재
2. 인출한 데이터 + AC 레지스터 내용 -> AC 레지스터에 저장

#### 프로그램 제어
- 분기(branch) 명령어
```
## JUMP addr

t0: PC <- IR(addr)
```
0. 분기 목적지 주소 적재, 명령어 실행 순서 변경  

### 인터럽트
#### 인터럽트 사이클
0. 인터럽트 가능 여부 파악
1. 현재 PC 주소 스택에 저장 (ISR 종료 후 복귀할 주소)
2. ISR 시작 주소 PC 적재

#### 마이크로 연산 과정
```
t0: MBR <- PC
t1: MAR <- SP, PC <- ISR의 시작 주소
t2: M[MAR] <- MBR, SP <- SP - 1

## SP(stack pointer) 
## => 스택의 최상위 주소, 일반적으로 주기억장치의 마지막 주소
```
0. PC 내용 MBR 전송
1. SP 내용 MAR을 통해 주소 버스로 나감, PC에 ISR 시작 주소 적재
2. MBR에 저장된 PC 내용 스택에 저장, SP 내용 감소

### 간접 사이클
```
## 명령어의 주소가 데이터가 저장된 기억 장소의 주소를 가리키는 경우
## 실행 사이클 이전에 데이터 실제 주소를 읽어오는 과정이 선행되어야 함
## 아마 c언어 포인터 비슷한듯

t0: MAR <- IR(addr)
t1: MBR <- M[MAR]
t2: IR(addr) <- MBR
```
0. 명령어 주소 받음
1. 주소 내용 다시 인출
2. IR에 저장
